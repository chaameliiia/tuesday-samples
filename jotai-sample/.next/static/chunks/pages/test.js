/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/test"],{

/***/ "./src/pages/test.tsx":
/*!****************************!*\
  !*** ./src/pages/test.tsx ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var jotai__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jotai */ \"./node_modules/jotai/esm/index.js\");\n/* harmony import */ var stores_inputAtom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! stores/inputAtom */ \"./src/stores/inputAtom.ts\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n\n\n\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\nvar _this = undefined;\nvar _s1 = $RefreshSig$();\nvar TestPage = function() {\n    _s1();\n    var ref = _slicedToArray((0,jotai__WEBPACK_IMPORTED_MODULE_2__.useAtom)(stores_inputAtom__WEBPACK_IMPORTED_MODULE_1__.inputAtom), 1), input = ref[0];\n    return(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n            __source: {\n                fileName: \"/Users/chaa/study/tuesday/jotai-sample/src/pages/test.tsx\",\n                lineNumber: 10\n            },\n            __self: _this,\n            children: [\n                \"input: \",\n                input\n            ]\n        })\n    }));\n};\n_s1(TestPage, \"BrCQ1umYhFSKP+0cybbAOjjILsU=\", false, function() {\n    return [\n        jotai__WEBPACK_IMPORTED_MODULE_2__.useAtom\n    ];\n});\n_c = TestPage;\n/* harmony default export */ __webpack_exports__[\"default\"] = (TestPage);\nvar _c;\n$RefreshReg$(_c, \"TestPage\");\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvdGVzdC50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErQjtBQUVhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRTVDLEdBQUssQ0FBQ0UsUUFBUSxHQUFHLFFBQ2pCLEdBRHVCLENBQUM7O0lBQ3RCLEdBQUssQ0FBV0YsR0FBa0Isa0JBQWxCQSw4Q0FBTyxDQUFDQyx1REFBUyxPQUExQkUsS0FBSyxHQUFJSCxHQUFrQjtJQUVsQyxNQUFNO3dGQUVESSxDQUFHOzs7Ozs7O2dCQUFDLENBQ0k7Z0JBQUNELEtBQUs7Ozs7QUFLckIsQ0FBQztJQVhLRCxRQUFROztRQUNJRiwwQ0FBTzs7O0tBRG5CRSxRQUFRO0FBYWQsK0RBQWVBLFFBQVEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvcGFnZXMvdGVzdC50c3g/NDhhOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VBdG9tIH0gZnJvbSBcImpvdGFpXCI7XG5cbmltcG9ydCB7IGlucHV0QXRvbSB9IGZyb20gXCJzdG9yZXMvaW5wdXRBdG9tXCI7XG5cbmNvbnN0IFRlc3RQYWdlID0gKCkgPT4ge1xuICBjb25zdCBbaW5wdXRdID0gdXNlQXRvbShpbnB1dEF0b20pO1xuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxkaXY+XG4gICAgICAgIGlucHV0OiB7aW5wdXR9XG4gICAgICA8L2Rpdj5cblxuICAgIDwvPlxuICApXG59O1xuXG5leHBvcnQgZGVmYXVsdCBUZXN0UGFnZTtcbiJdLCJuYW1lcyI6WyJ1c2VBdG9tIiwiaW5wdXRBdG9tIiwiVGVzdFBhZ2UiLCJpbnB1dCIsImRpdiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/pages/test.tsx\n");

/***/ }),

/***/ "./src/stores/inputAtom.ts":
/*!*********************************!*\
  !*** ./src/stores/inputAtom.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"inputAtom\": function() { return /* binding */ inputAtom; }\n/* harmony export */ });\n/* harmony import */ var jotai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jotai */ \"./node_modules/jotai/esm/index.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n\nvar inputAtom = (0,jotai__WEBPACK_IMPORTED_MODULE_0__.atom)('');\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3RvcmVzL2lucHV0QXRvbS50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNEI7QUFFckIsR0FBSyxDQUFDQyxTQUFTLEdBQUdELDJDQUFJLENBQUMsQ0FBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3RvcmVzL2lucHV0QXRvbS50cz84MmZhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGF0b20gfSBmcm9tICdqb3RhaSc7XG5cbmV4cG9ydCBjb25zdCBpbnB1dEF0b20gPSBhdG9tKCcnKVxuIl0sIm5hbWVzIjpbImF0b20iLCJpbnB1dEF0b20iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/stores/inputAtom.ts\n");

/***/ }),

/***/ "./node_modules/jotai/esm/index.js":
/*!*****************************************!*\
  !*** ./node_modules/jotai/esm/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Provider\": function() { return /* binding */ Provider; },\n/* harmony export */   \"SECRET_INTERNAL_getScopeContext\": function() { return /* binding */ getScopeContext; },\n/* harmony export */   \"atom\": function() { return /* binding */ atom; },\n/* harmony export */   \"useAtom\": function() { return /* binding */ useAtom; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\n\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst IS_EQUAL_PROMISE = Symbol();\nconst INTERRUPT_PROMISE = Symbol();\nconst isInterruptablePromise = (promise) => !!promise[INTERRUPT_PROMISE];\nconst createInterruptablePromise = (promise) => {\n  let interrupt;\n  const interruptablePromise = new Promise((resolve, reject) => {\n    interrupt = () => {\n      delete interruptablePromise[INTERRUPT_PROMISE];\n      resolve();\n    };\n    promise.then(resolve, reject);\n  });\n  interruptablePromise[IS_EQUAL_PROMISE] = (p) => interruptablePromise === p || promise === p || isInterruptablePromise(promise) && promise[IS_EQUAL_PROMISE](p);\n  interruptablePromise[INTERRUPT_PROMISE] = interrupt;\n  return interruptablePromise;\n};\nconst READ_ATOM = \"r\";\nconst WRITE_ATOM = \"w\";\nconst COMMIT_ATOM = \"c\";\nconst SUBSCRIBE_ATOM = \"s\";\nconst RESTORE_ATOMS = \"h\";\nconst DEV_SUBSCRIBE_STATE = \"n\";\nconst DEV_GET_MOUNTED_ATOMS = \"l\";\nconst DEV_GET_ATOM_STATE = \"a\";\nconst DEV_GET_MOUNTED = \"m\";\nconst createStore = (initialValues) => {\n  const atomStateMap = new WeakMap();\n  const mountedMap = new WeakMap();\n  const pendingMap = new Map();\n  let stateListeners;\n  let mountedAtoms;\n  if (typeof process === \"object\" && \"development\" !== \"production\") {\n    stateListeners = new Set();\n    mountedAtoms = new Set();\n  }\n  if (initialValues) {\n    for (const [atom, value] of initialValues) {\n      const atomState = { v: value, r: 0, d: new Map() };\n      if (typeof process === \"object\" && \"development\" !== \"production\") {\n        Object.freeze(atomState);\n        if (!hasInitialValue(atom)) {\n          console.warn(\"Found initial value for derived atom which can cause unexpected behavior\", atom);\n        }\n      }\n      atomStateMap.set(atom, atomState);\n    }\n  }\n  const getAtomState = (atom) => atomStateMap.get(atom);\n  const setAtomState = (atom, atomState) => {\n    if (typeof process === \"object\" && \"development\" !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = atomStateMap.get(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n  };\n  const prepareNextAtomState = (atom, dependencies) => {\n    const atomState = getAtomState(atom);\n    const nextAtomState = __spreadProps(__spreadValues({\n      r: 0\n    }, atomState), {\n      d: dependencies ? new Map(Array.from(dependencies).map((a) => {\n        var _a, _b;\n        return [a, (_b = (_a = getAtomState(a)) == null ? void 0 : _a.r) != null ? _b : 0];\n      })) : (atomState == null ? void 0 : atomState.d) || new Map()\n    });\n    return nextAtomState;\n  };\n  const setAtomValue = (atom, value, dependencies, promise) => {\n    var _a, _b;\n    const atomState = prepareNextAtomState(atom, dependencies);\n    if (promise && !((_a = atomState.p) == null ? void 0 : _a[IS_EQUAL_PROMISE](promise))) {\n      return;\n    }\n    (_b = atomState.c) == null ? void 0 : _b.call(atomState);\n    if (\"e\" in atomState || atomState.p || !(\"v\" in atomState) || !Object.is(atomState.v, value)) {\n      ++atomState.r;\n      if (atomState.d.has(atom)) {\n        atomState.d.set(atom, atomState.r);\n      }\n    }\n    atomState.v = value;\n    delete atomState.e;\n    delete atomState.p;\n    delete atomState.c;\n    delete atomState.i;\n    setAtomState(atom, atomState);\n  };\n  const setAtomReadError = (atom, error, dependencies, promise) => {\n    var _a, _b;\n    const atomState = prepareNextAtomState(atom, dependencies);\n    if (promise && !((_a = atomState.p) == null ? void 0 : _a[IS_EQUAL_PROMISE](promise))) {\n      return;\n    }\n    (_b = atomState.c) == null ? void 0 : _b.call(atomState);\n    delete atomState.p;\n    delete atomState.c;\n    delete atomState.i;\n    atomState.e = error;\n    setAtomState(atom, atomState);\n  };\n  const setAtomReadPromise = (atom, promise, dependencies) => {\n    var _a, _b;\n    const atomState = prepareNextAtomState(atom, dependencies);\n    if ((_a = atomState.p) == null ? void 0 : _a[IS_EQUAL_PROMISE](promise)) {\n      return;\n    }\n    (_b = atomState.c) == null ? void 0 : _b.call(atomState);\n    delete atomState.e;\n    const interruptablePromise = createInterruptablePromise(promise);\n    atomState.p = interruptablePromise;\n    atomState.c = interruptablePromise[INTERRUPT_PROMISE];\n    setAtomState(atom, atomState);\n  };\n  const setAtomInvalidated = (atom) => {\n    const atomState = prepareNextAtomState(atom);\n    atomState.i = atomState.r;\n    setAtomState(atom, atomState);\n  };\n  const readAtomState = (atom, force) => {\n    if (!force) {\n      const atomState = getAtomState(atom);\n      if (atomState) {\n        atomState.d.forEach((_, a) => {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(a);\n            } else {\n              const aState = getAtomState(a);\n              if (aState && !(\"e\" in aState) && !aState.p && aState.r === aState.i) {\n                readAtomState(a, true);\n              }\n            }\n          }\n        });\n        if (Array.from(atomState.d.entries()).every(([a, r]) => {\n          const aState = getAtomState(a);\n          return aState && !(\"e\" in aState) && !aState.p && aState.r !== aState.i && aState.r === r;\n        })) {\n          return atomState;\n        }\n      }\n    }\n    let error;\n    let promise;\n    let value;\n    const dependencies = new Set();\n    try {\n      const promiseOrValue = atom.read((a) => {\n        dependencies.add(a);\n        const aState = a === atom ? getAtomState(a) : readAtomState(a);\n        if (aState) {\n          if (\"e\" in aState) {\n            throw aState.e;\n          }\n          if (aState.p) {\n            throw aState.p;\n          }\n          return aState.v;\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      });\n      if (promiseOrValue instanceof Promise) {\n        promise = promiseOrValue.then((value2) => {\n          setAtomValue(atom, value2, dependencies, promise);\n          flushPending();\n        }).catch((e) => {\n          if (e instanceof Promise) {\n            if (!isInterruptablePromise(e) || !e[INTERRUPT_PROMISE]) {\n              e.finally(() => readAtomState(atom, true));\n            }\n            return e;\n          }\n          setAtomReadError(atom, e, dependencies, promise);\n          flushPending();\n        });\n      } else {\n        value = promiseOrValue;\n      }\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        promise = errorOrPromise;\n      } else {\n        error = errorOrPromise;\n      }\n    }\n    if (error) {\n      setAtomReadError(atom, error, dependencies);\n    } else if (promise) {\n      setAtomReadPromise(atom, promise, dependencies);\n    } else {\n      setAtomValue(atom, value, dependencies);\n    }\n    return getAtomState(atom);\n  };\n  const readAtom = (readingAtom) => {\n    const atomState = readAtomState(readingAtom);\n    return atomState;\n  };\n  const addAtom = (addingAtom) => {\n    let mounted = mountedMap.get(addingAtom);\n    if (!mounted) {\n      mounted = mountAtom(addingAtom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.d.size || mounted.d.size === 1 && mounted.d.has(atom));\n  const delAtom = (deletingAtom) => {\n    const mounted = mountedMap.get(deletingAtom);\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(deletingAtom);\n    }\n  };\n  const invalidateDependents = (atom) => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.d.forEach((dependent) => {\n      if (dependent === atom) {\n        return;\n      }\n      setAtomInvalidated(dependent);\n      invalidateDependents(dependent);\n    });\n  };\n  const writeAtomState = (atom, update) => {\n    const writeGetter = (a, unstable_promise = false) => {\n      const aState = readAtomState(a);\n      if (\"e\" in aState) {\n        throw aState.e;\n      }\n      if (aState.p) {\n        if (typeof process === \"object\" && \"development\" !== \"production\") {\n          if (unstable_promise) {\n            console.info(\"promise option in getter is an experimental feature.\", a);\n          } else {\n            console.warn(\"Reading pending atom state in write operation. We throw a promise for now.\", a);\n          }\n        }\n        if (unstable_promise) {\n          return aState.p.then(() => writeGetter(a, unstable_promise));\n        }\n        throw aState.p;\n      }\n      if (\"v\" in aState) {\n        return aState.v;\n      }\n      if (typeof process === \"object\" && \"development\" !== \"production\") {\n        console.warn(\"[Bug] no value found while reading atom in write operation. This is probably a bug.\", a);\n      }\n      throw new Error(\"no value found\");\n    };\n    const setter = (a, v) => {\n      let promiseOrVoid2;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"no atom init\");\n        }\n        if (v instanceof Promise) {\n          promiseOrVoid2 = v.then((resolvedValue) => {\n            setAtomValue(a, resolvedValue);\n            invalidateDependents(a);\n            flushPending();\n          }).catch((e) => {\n            setAtomReadError(atom, e);\n            flushPending();\n          });\n          setAtomReadPromise(atom, promiseOrVoid2);\n        } else {\n          setAtomValue(a, v);\n        }\n        invalidateDependents(a);\n        flushPending();\n      } else {\n        promiseOrVoid2 = writeAtomState(a, v);\n      }\n      return promiseOrVoid2;\n    };\n    const promiseOrVoid = atom.write(writeGetter, setter, update);\n    flushPending();\n    return promiseOrVoid;\n  };\n  const writeAtom = (writingAtom, update) => {\n    const promiseOrVoid = writeAtomState(writingAtom, update);\n    return promiseOrVoid;\n  };\n  const isActuallyWritableAtom = (atom) => !!atom.write;\n  const mountAtom = (atom, initialDependent) => {\n    const atomState = readAtomState(atom);\n    atomState.d.forEach((_, a) => {\n      if (a !== atom) {\n        const aMounted = mountedMap.get(a);\n        if (aMounted) {\n          aMounted.d.add(atom);\n        } else {\n          mountAtom(a, atom);\n        }\n      }\n    });\n    const mounted = {\n      d: new Set(initialDependent && [initialDependent]),\n      l: new Set(),\n      u: void 0\n    };\n    mountedMap.set(atom, mounted);\n    if (typeof process === \"object\" && \"development\" !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const setAtom = (update) => writeAtom(atom, update);\n      mounted.u = atom.onMount(setAtom);\n    }\n    return mounted;\n  };\n  const unmountAtom = (atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if (typeof process === \"object\" && \"development\" !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.d.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if (typeof process === \"object\" && \"development\" !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevReadDependencies) => {\n    const dependencies = new Set(atomState.d.keys());\n    prevReadDependencies.forEach((_, a) => {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.d.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    dependencies.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        const dependents = mounted.d;\n        dependents.add(atom);\n      } else {\n        mountAtom(a, atom);\n      }\n    });\n  };\n  const flushPending = () => {\n    const pending = Array.from(pendingMap);\n    pendingMap.clear();\n    pending.forEach(([atom, prevAtomState]) => {\n      const atomState = getAtomState(atom);\n      if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n        mountDependencies(atom, atomState, (prevAtomState == null ? void 0 : prevAtomState.d) || new Map());\n      }\n      const mounted = mountedMap.get(atom);\n      mounted == null ? void 0 : mounted.l.forEach((listener) => listener());\n      if (typeof process === \"object\" && \"development\" !== \"production\") {\n        stateListeners.forEach((l) => l(atom, !prevAtomState));\n      }\n    });\n  };\n  const commitAtom = (_atom) => {\n    flushPending();\n  };\n  const subscribeAtom = (atom, callback) => {\n    const mounted = addAtom(atom);\n    const listeners = mounted.l;\n    listeners.add(callback);\n    return () => {\n      listeners.delete(callback);\n      delAtom(atom);\n    };\n  };\n  const restoreAtoms = (values) => {\n    for (const [atom, value] of values) {\n      if (hasInitialValue(atom)) {\n        setAtomValue(atom, value);\n        invalidateDependents(atom);\n      }\n    }\n    flushPending();\n  };\n  if (typeof process === \"object\" && \"development\" !== \"production\") {\n    return {\n      [READ_ATOM]: readAtom,\n      [WRITE_ATOM]: writeAtom,\n      [COMMIT_ATOM]: commitAtom,\n      [SUBSCRIBE_ATOM]: subscribeAtom,\n      [RESTORE_ATOMS]: restoreAtoms,\n      [DEV_SUBSCRIBE_STATE]: (l) => {\n        stateListeners.add(l);\n        return () => {\n          stateListeners.delete(l);\n        };\n      },\n      [DEV_GET_MOUNTED_ATOMS]: () => mountedAtoms.values(),\n      [DEV_GET_ATOM_STATE]: (a) => atomStateMap.get(a),\n      [DEV_GET_MOUNTED]: (a) => mountedMap.get(a)\n    };\n  }\n  return {\n    [READ_ATOM]: readAtom,\n    [WRITE_ATOM]: writeAtom,\n    [COMMIT_ATOM]: commitAtom,\n    [SUBSCRIBE_ATOM]: subscribeAtom,\n    [RESTORE_ATOMS]: restoreAtoms\n  };\n};\n\nconst createScopeContainer = (initialValues) => {\n  const store = createStore(initialValues);\n  return { s: store };\n};\nconst ScopeContextMap = new Map();\nconst getScopeContext = (scope) => {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(createScopeContainer()));\n  }\n  return ScopeContextMap.get(scope);\n};\n\nconst Provider = ({\n  initialValues,\n  scope,\n  children\n}) => {\n  const scopeContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  if (!scopeContainerRef.current) {\n    scopeContainerRef.current = createScopeContainer(initialValues);\n  }\n  if (typeof process === \"object\" && \"development\" !== \"production\" && \"development\" !== \"test\") {\n    useDebugState(scopeContainerRef.current);\n  }\n  const ScopeContainerContext = getScopeContext(scope);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(ScopeContainerContext.Provider, {\n    value: scopeContainerRef.current\n  }, children);\n};\nconst atomToPrintable = (atom) => atom.debugLabel || atom.toString();\nconst stateToPrintable = ([store, atoms]) => Object.fromEntries(atoms.flatMap((atom) => {\n  var _a, _b;\n  const mounted = (_a = store[DEV_GET_MOUNTED]) == null ? void 0 : _a.call(store, atom);\n  if (!mounted) {\n    return [];\n  }\n  const dependents = mounted.d;\n  const atomState = ((_b = store[DEV_GET_ATOM_STATE]) == null ? void 0 : _b.call(store, atom)) || {};\n  return [\n    [\n      atomToPrintable(atom),\n      {\n        value: atomState.e || atomState.p || atomState.v,\n        dependents: Array.from(dependents).map(atomToPrintable)\n      }\n    ]\n  ];\n}));\nconst useDebugState = (scopeContainer) => {\n  const store = scopeContainer.s;\n  const [atoms, setAtoms] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    var _a;\n    const callback = () => {\n      var _a2;\n      setAtoms(Array.from(((_a2 = store[DEV_GET_MOUNTED_ATOMS]) == null ? void 0 : _a2.call(store)) || []));\n    };\n    const unsubscribe = (_a = store[DEV_SUBSCRIBE_STATE]) == null ? void 0 : _a.call(store, callback);\n    callback();\n    return unsubscribe;\n  }, [store]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)([store, atoms], stateToPrintable);\n};\n\nlet keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = (get) => get(config);\n    config.write = (get, set, update) => set(config, typeof update === \"function\" ? update(get(config)) : update);\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\n\nconst isWritable = (atom) => !!atom.write;\nfunction useAtom(atom, scope) {\n  if (\"scope\" in atom) {\n    console.warn(\"atom.scope is deprecated. Please do useAtom(atom, scope) instead.\");\n    scope = atom.scope;\n  }\n  const ScopeContext = getScopeContext(scope);\n  const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ScopeContext).s;\n  const getAtomValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (atomState.p) {\n      throw atomState.p;\n    }\n    if (\"v\" in atomState) {\n      return atomState.v;\n    }\n    throw new Error(\"no atom value\");\n  }, [store, atom]);\n  const [value, forceUpdate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(getAtomValue, void 0, getAtomValue);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const unsubscribe = store[SUBSCRIBE_ATOM](atom, forceUpdate);\n    forceUpdate();\n    return unsubscribe;\n  }, [store, atom]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    store[COMMIT_ATOM](atom);\n  });\n  const setAtom = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((update) => {\n    if (isWritable(atom)) {\n      return store[WRITE_ATOM](atom, update);\n    } else {\n      throw new Error(\"not writable atom\");\n    }\n  }, [store, atom]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(value);\n  return [value, setAtom];\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsb0RBQWE7QUFDZjtBQUNBOztBQUV1RiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL2luZGV4LmpzP2ZkZGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlUmVmLCBjcmVhdGVFbGVtZW50LCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VEZWJ1Z1ZhbHVlLCB1c2VDb250ZXh0LCB1c2VDYWxsYmFjaywgdXNlUmVkdWNlciB9IGZyb20gJ3JlYWN0JztcblxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG5jb25zdCBoYXNJbml0aWFsVmFsdWUgPSAoYXRvbSkgPT4gXCJpbml0XCIgaW4gYXRvbTtcbmNvbnN0IElTX0VRVUFMX1BST01JU0UgPSBTeW1ib2woKTtcbmNvbnN0IElOVEVSUlVQVF9QUk9NSVNFID0gU3ltYm9sKCk7XG5jb25zdCBpc0ludGVycnVwdGFibGVQcm9taXNlID0gKHByb21pc2UpID0+ICEhcHJvbWlzZVtJTlRFUlJVUFRfUFJPTUlTRV07XG5jb25zdCBjcmVhdGVJbnRlcnJ1cHRhYmxlUHJvbWlzZSA9IChwcm9taXNlKSA9PiB7XG4gIGxldCBpbnRlcnJ1cHQ7XG4gIGNvbnN0IGludGVycnVwdGFibGVQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGludGVycnVwdCA9ICgpID0+IHtcbiAgICAgIGRlbGV0ZSBpbnRlcnJ1cHRhYmxlUHJvbWlzZVtJTlRFUlJVUFRfUFJPTUlTRV07XG4gICAgICByZXNvbHZlKCk7XG4gICAgfTtcbiAgICBwcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgfSk7XG4gIGludGVycnVwdGFibGVQcm9taXNlW0lTX0VRVUFMX1BST01JU0VdID0gKHApID0+IGludGVycnVwdGFibGVQcm9taXNlID09PSBwIHx8IHByb21pc2UgPT09IHAgfHwgaXNJbnRlcnJ1cHRhYmxlUHJvbWlzZShwcm9taXNlKSAmJiBwcm9taXNlW0lTX0VRVUFMX1BST01JU0VdKHApO1xuICBpbnRlcnJ1cHRhYmxlUHJvbWlzZVtJTlRFUlJVUFRfUFJPTUlTRV0gPSBpbnRlcnJ1cHQ7XG4gIHJldHVybiBpbnRlcnJ1cHRhYmxlUHJvbWlzZTtcbn07XG5jb25zdCBSRUFEX0FUT00gPSBcInJcIjtcbmNvbnN0IFdSSVRFX0FUT00gPSBcIndcIjtcbmNvbnN0IENPTU1JVF9BVE9NID0gXCJjXCI7XG5jb25zdCBTVUJTQ1JJQkVfQVRPTSA9IFwic1wiO1xuY29uc3QgUkVTVE9SRV9BVE9NUyA9IFwiaFwiO1xuY29uc3QgREVWX1NVQlNDUklCRV9TVEFURSA9IFwiblwiO1xuY29uc3QgREVWX0dFVF9NT1VOVEVEX0FUT01TID0gXCJsXCI7XG5jb25zdCBERVZfR0VUX0FUT01fU1RBVEUgPSBcImFcIjtcbmNvbnN0IERFVl9HRVRfTU9VTlRFRCA9IFwibVwiO1xuY29uc3QgY3JlYXRlU3RvcmUgPSAoaW5pdGlhbFZhbHVlcykgPT4ge1xuICBjb25zdCBhdG9tU3RhdGVNYXAgPSBuZXcgV2Vha01hcCgpO1xuICBjb25zdCBtb3VudGVkTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgY29uc3QgcGVuZGluZ01hcCA9IG5ldyBNYXAoKTtcbiAgbGV0IHN0YXRlTGlzdGVuZXJzO1xuICBsZXQgbW91bnRlZEF0b21zO1xuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgc3RhdGVMaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgbW91bnRlZEF0b21zID0gbmV3IFNldCgpO1xuICB9XG4gIGlmIChpbml0aWFsVmFsdWVzKSB7XG4gICAgZm9yIChjb25zdCBbYXRvbSwgdmFsdWVdIG9mIGluaXRpYWxWYWx1ZXMpIHtcbiAgICAgIGNvbnN0IGF0b21TdGF0ZSA9IHsgdjogdmFsdWUsIHI6IDAsIGQ6IG5ldyBNYXAoKSB9O1xuICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBPYmplY3QuZnJlZXplKGF0b21TdGF0ZSk7XG4gICAgICAgIGlmICghaGFzSW5pdGlhbFZhbHVlKGF0b20pKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiRm91bmQgaW5pdGlhbCB2YWx1ZSBmb3IgZGVyaXZlZCBhdG9tIHdoaWNoIGNhbiBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW9yXCIsIGF0b20pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhdG9tU3RhdGVNYXAuc2V0KGF0b20sIGF0b21TdGF0ZSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGdldEF0b21TdGF0ZSA9IChhdG9tKSA9PiBhdG9tU3RhdGVNYXAuZ2V0KGF0b20pO1xuICBjb25zdCBzZXRBdG9tU3RhdGUgPSAoYXRvbSwgYXRvbVN0YXRlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgT2JqZWN0LmZyZWV6ZShhdG9tU3RhdGUpO1xuICAgIH1cbiAgICBjb25zdCBwcmV2QXRvbVN0YXRlID0gYXRvbVN0YXRlTWFwLmdldChhdG9tKTtcbiAgICBhdG9tU3RhdGVNYXAuc2V0KGF0b20sIGF0b21TdGF0ZSk7XG4gICAgaWYgKCFwZW5kaW5nTWFwLmhhcyhhdG9tKSkge1xuICAgICAgcGVuZGluZ01hcC5zZXQoYXRvbSwgcHJldkF0b21TdGF0ZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBwcmVwYXJlTmV4dEF0b21TdGF0ZSA9IChhdG9tLCBkZXBlbmRlbmNpZXMpID0+IHtcbiAgICBjb25zdCBhdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgY29uc3QgbmV4dEF0b21TdGF0ZSA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgcjogMFxuICAgIH0sIGF0b21TdGF0ZSksIHtcbiAgICAgIGQ6IGRlcGVuZGVuY2llcyA/IG5ldyBNYXAoQXJyYXkuZnJvbShkZXBlbmRlbmNpZXMpLm1hcCgoYSkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gW2EsIChfYiA9IChfYSA9IGdldEF0b21TdGF0ZShhKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnIpICE9IG51bGwgPyBfYiA6IDBdO1xuICAgICAgfSkpIDogKGF0b21TdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogYXRvbVN0YXRlLmQpIHx8IG5ldyBNYXAoKVxuICAgIH0pO1xuICAgIHJldHVybiBuZXh0QXRvbVN0YXRlO1xuICB9O1xuICBjb25zdCBzZXRBdG9tVmFsdWUgPSAoYXRvbSwgdmFsdWUsIGRlcGVuZGVuY2llcywgcHJvbWlzZSkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgYXRvbVN0YXRlID0gcHJlcGFyZU5leHRBdG9tU3RhdGUoYXRvbSwgZGVwZW5kZW5jaWVzKTtcbiAgICBpZiAocHJvbWlzZSAmJiAhKChfYSA9IGF0b21TdGF0ZS5wKSA9PSBudWxsID8gdm9pZCAwIDogX2FbSVNfRVFVQUxfUFJPTUlTRV0ocHJvbWlzZSkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIChfYiA9IGF0b21TdGF0ZS5jKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChhdG9tU3RhdGUpO1xuICAgIGlmIChcImVcIiBpbiBhdG9tU3RhdGUgfHwgYXRvbVN0YXRlLnAgfHwgIShcInZcIiBpbiBhdG9tU3RhdGUpIHx8ICFPYmplY3QuaXMoYXRvbVN0YXRlLnYsIHZhbHVlKSkge1xuICAgICAgKythdG9tU3RhdGUucjtcbiAgICAgIGlmIChhdG9tU3RhdGUuZC5oYXMoYXRvbSkpIHtcbiAgICAgICAgYXRvbVN0YXRlLmQuc2V0KGF0b20sIGF0b21TdGF0ZS5yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXRvbVN0YXRlLnYgPSB2YWx1ZTtcbiAgICBkZWxldGUgYXRvbVN0YXRlLmU7XG4gICAgZGVsZXRlIGF0b21TdGF0ZS5wO1xuICAgIGRlbGV0ZSBhdG9tU3RhdGUuYztcbiAgICBkZWxldGUgYXRvbVN0YXRlLmk7XG4gICAgc2V0QXRvbVN0YXRlKGF0b20sIGF0b21TdGF0ZSk7XG4gIH07XG4gIGNvbnN0IHNldEF0b21SZWFkRXJyb3IgPSAoYXRvbSwgZXJyb3IsIGRlcGVuZGVuY2llcywgcHJvbWlzZSkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgYXRvbVN0YXRlID0gcHJlcGFyZU5leHRBdG9tU3RhdGUoYXRvbSwgZGVwZW5kZW5jaWVzKTtcbiAgICBpZiAocHJvbWlzZSAmJiAhKChfYSA9IGF0b21TdGF0ZS5wKSA9PSBudWxsID8gdm9pZCAwIDogX2FbSVNfRVFVQUxfUFJPTUlTRV0ocHJvbWlzZSkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIChfYiA9IGF0b21TdGF0ZS5jKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChhdG9tU3RhdGUpO1xuICAgIGRlbGV0ZSBhdG9tU3RhdGUucDtcbiAgICBkZWxldGUgYXRvbVN0YXRlLmM7XG4gICAgZGVsZXRlIGF0b21TdGF0ZS5pO1xuICAgIGF0b21TdGF0ZS5lID0gZXJyb3I7XG4gICAgc2V0QXRvbVN0YXRlKGF0b20sIGF0b21TdGF0ZSk7XG4gIH07XG4gIGNvbnN0IHNldEF0b21SZWFkUHJvbWlzZSA9IChhdG9tLCBwcm9taXNlLCBkZXBlbmRlbmNpZXMpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGF0b21TdGF0ZSA9IHByZXBhcmVOZXh0QXRvbVN0YXRlKGF0b20sIGRlcGVuZGVuY2llcyk7XG4gICAgaWYgKChfYSA9IGF0b21TdGF0ZS5wKSA9PSBudWxsID8gdm9pZCAwIDogX2FbSVNfRVFVQUxfUFJPTUlTRV0ocHJvbWlzZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgKF9iID0gYXRvbVN0YXRlLmMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKGF0b21TdGF0ZSk7XG4gICAgZGVsZXRlIGF0b21TdGF0ZS5lO1xuICAgIGNvbnN0IGludGVycnVwdGFibGVQcm9taXNlID0gY3JlYXRlSW50ZXJydXB0YWJsZVByb21pc2UocHJvbWlzZSk7XG4gICAgYXRvbVN0YXRlLnAgPSBpbnRlcnJ1cHRhYmxlUHJvbWlzZTtcbiAgICBhdG9tU3RhdGUuYyA9IGludGVycnVwdGFibGVQcm9taXNlW0lOVEVSUlVQVF9QUk9NSVNFXTtcbiAgICBzZXRBdG9tU3RhdGUoYXRvbSwgYXRvbVN0YXRlKTtcbiAgfTtcbiAgY29uc3Qgc2V0QXRvbUludmFsaWRhdGVkID0gKGF0b20pID0+IHtcbiAgICBjb25zdCBhdG9tU3RhdGUgPSBwcmVwYXJlTmV4dEF0b21TdGF0ZShhdG9tKTtcbiAgICBhdG9tU3RhdGUuaSA9IGF0b21TdGF0ZS5yO1xuICAgIHNldEF0b21TdGF0ZShhdG9tLCBhdG9tU3RhdGUpO1xuICB9O1xuICBjb25zdCByZWFkQXRvbVN0YXRlID0gKGF0b20sIGZvcmNlKSA9PiB7XG4gICAgaWYgKCFmb3JjZSkge1xuICAgICAgY29uc3QgYXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKGF0b20pO1xuICAgICAgaWYgKGF0b21TdGF0ZSkge1xuICAgICAgICBhdG9tU3RhdGUuZC5mb3JFYWNoKChfLCBhKSA9PiB7XG4gICAgICAgICAgaWYgKGEgIT09IGF0b20pIHtcbiAgICAgICAgICAgIGlmICghbW91bnRlZE1hcC5oYXMoYSkpIHtcbiAgICAgICAgICAgICAgcmVhZEF0b21TdGF0ZShhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFTdGF0ZSA9IGdldEF0b21TdGF0ZShhKTtcbiAgICAgICAgICAgICAgaWYgKGFTdGF0ZSAmJiAhKFwiZVwiIGluIGFTdGF0ZSkgJiYgIWFTdGF0ZS5wICYmIGFTdGF0ZS5yID09PSBhU3RhdGUuaSkge1xuICAgICAgICAgICAgICAgIHJlYWRBdG9tU3RhdGUoYSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoQXJyYXkuZnJvbShhdG9tU3RhdGUuZC5lbnRyaWVzKCkpLmV2ZXJ5KChbYSwgcl0pID0+IHtcbiAgICAgICAgICBjb25zdCBhU3RhdGUgPSBnZXRBdG9tU3RhdGUoYSk7XG4gICAgICAgICAgcmV0dXJuIGFTdGF0ZSAmJiAhKFwiZVwiIGluIGFTdGF0ZSkgJiYgIWFTdGF0ZS5wICYmIGFTdGF0ZS5yICE9PSBhU3RhdGUuaSAmJiBhU3RhdGUuciA9PT0gcjtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICByZXR1cm4gYXRvbVN0YXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBlcnJvcjtcbiAgICBsZXQgcHJvbWlzZTtcbiAgICBsZXQgdmFsdWU7XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gbmV3IFNldCgpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcm9taXNlT3JWYWx1ZSA9IGF0b20ucmVhZCgoYSkgPT4ge1xuICAgICAgICBkZXBlbmRlbmNpZXMuYWRkKGEpO1xuICAgICAgICBjb25zdCBhU3RhdGUgPSBhID09PSBhdG9tID8gZ2V0QXRvbVN0YXRlKGEpIDogcmVhZEF0b21TdGF0ZShhKTtcbiAgICAgICAgaWYgKGFTdGF0ZSkge1xuICAgICAgICAgIGlmIChcImVcIiBpbiBhU3RhdGUpIHtcbiAgICAgICAgICAgIHRocm93IGFTdGF0ZS5lO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYVN0YXRlLnApIHtcbiAgICAgICAgICAgIHRocm93IGFTdGF0ZS5wO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYVN0YXRlLnY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0luaXRpYWxWYWx1ZShhKSkge1xuICAgICAgICAgIHJldHVybiBhLmluaXQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gYXRvbSBpbml0XCIpO1xuICAgICAgfSk7XG4gICAgICBpZiAocHJvbWlzZU9yVmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHByb21pc2UgPSBwcm9taXNlT3JWYWx1ZS50aGVuKCh2YWx1ZTIpID0+IHtcbiAgICAgICAgICBzZXRBdG9tVmFsdWUoYXRvbSwgdmFsdWUyLCBkZXBlbmRlbmNpZXMsIHByb21pc2UpO1xuICAgICAgICAgIGZsdXNoUGVuZGluZygpO1xuICAgICAgICB9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgaWYgKCFpc0ludGVycnVwdGFibGVQcm9taXNlKGUpIHx8ICFlW0lOVEVSUlVQVF9QUk9NSVNFXSkge1xuICAgICAgICAgICAgICBlLmZpbmFsbHkoKCkgPT4gcmVhZEF0b21TdGF0ZShhdG9tLCB0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0QXRvbVJlYWRFcnJvcihhdG9tLCBlLCBkZXBlbmRlbmNpZXMsIHByb21pc2UpO1xuICAgICAgICAgIGZsdXNoUGVuZGluZygpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gcHJvbWlzZU9yVmFsdWU7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3JPclByb21pc2UpIHtcbiAgICAgIGlmIChlcnJvck9yUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcHJvbWlzZSA9IGVycm9yT3JQcm9taXNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IgPSBlcnJvck9yUHJvbWlzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBzZXRBdG9tUmVhZEVycm9yKGF0b20sIGVycm9yLCBkZXBlbmRlbmNpZXMpO1xuICAgIH0gZWxzZSBpZiAocHJvbWlzZSkge1xuICAgICAgc2V0QXRvbVJlYWRQcm9taXNlKGF0b20sIHByb21pc2UsIGRlcGVuZGVuY2llcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEF0b21WYWx1ZShhdG9tLCB2YWx1ZSwgZGVwZW5kZW5jaWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEF0b21TdGF0ZShhdG9tKTtcbiAgfTtcbiAgY29uc3QgcmVhZEF0b20gPSAocmVhZGluZ0F0b20pID0+IHtcbiAgICBjb25zdCBhdG9tU3RhdGUgPSByZWFkQXRvbVN0YXRlKHJlYWRpbmdBdG9tKTtcbiAgICByZXR1cm4gYXRvbVN0YXRlO1xuICB9O1xuICBjb25zdCBhZGRBdG9tID0gKGFkZGluZ0F0b20pID0+IHtcbiAgICBsZXQgbW91bnRlZCA9IG1vdW50ZWRNYXAuZ2V0KGFkZGluZ0F0b20pO1xuICAgIGlmICghbW91bnRlZCkge1xuICAgICAgbW91bnRlZCA9IG1vdW50QXRvbShhZGRpbmdBdG9tKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vdW50ZWQ7XG4gIH07XG4gIGNvbnN0IGNhblVubW91bnRBdG9tID0gKGF0b20sIG1vdW50ZWQpID0+ICFtb3VudGVkLmwuc2l6ZSAmJiAoIW1vdW50ZWQuZC5zaXplIHx8IG1vdW50ZWQuZC5zaXplID09PSAxICYmIG1vdW50ZWQuZC5oYXMoYXRvbSkpO1xuICBjb25zdCBkZWxBdG9tID0gKGRlbGV0aW5nQXRvbSkgPT4ge1xuICAgIGNvbnN0IG1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChkZWxldGluZ0F0b20pO1xuICAgIGlmIChtb3VudGVkICYmIGNhblVubW91bnRBdG9tKGRlbGV0aW5nQXRvbSwgbW91bnRlZCkpIHtcbiAgICAgIHVubW91bnRBdG9tKGRlbGV0aW5nQXRvbSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBpbnZhbGlkYXRlRGVwZW5kZW50cyA9IChhdG9tKSA9PiB7XG4gICAgY29uc3QgbW91bnRlZCA9IG1vdW50ZWRNYXAuZ2V0KGF0b20pO1xuICAgIG1vdW50ZWQgPT0gbnVsbCA/IHZvaWQgMCA6IG1vdW50ZWQuZC5mb3JFYWNoKChkZXBlbmRlbnQpID0+IHtcbiAgICAgIGlmIChkZXBlbmRlbnQgPT09IGF0b20pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0QXRvbUludmFsaWRhdGVkKGRlcGVuZGVudCk7XG4gICAgICBpbnZhbGlkYXRlRGVwZW5kZW50cyhkZXBlbmRlbnQpO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCB3cml0ZUF0b21TdGF0ZSA9IChhdG9tLCB1cGRhdGUpID0+IHtcbiAgICBjb25zdCB3cml0ZUdldHRlciA9IChhLCB1bnN0YWJsZV9wcm9taXNlID0gZmFsc2UpID0+IHtcbiAgICAgIGNvbnN0IGFTdGF0ZSA9IHJlYWRBdG9tU3RhdGUoYSk7XG4gICAgICBpZiAoXCJlXCIgaW4gYVN0YXRlKSB7XG4gICAgICAgIHRocm93IGFTdGF0ZS5lO1xuICAgICAgfVxuICAgICAgaWYgKGFTdGF0ZS5wKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICBpZiAodW5zdGFibGVfcHJvbWlzZSkge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwicHJvbWlzZSBvcHRpb24gaW4gZ2V0dGVyIGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlLlwiLCBhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiUmVhZGluZyBwZW5kaW5nIGF0b20gc3RhdGUgaW4gd3JpdGUgb3BlcmF0aW9uLiBXZSB0aHJvdyBhIHByb21pc2UgZm9yIG5vdy5cIiwgYSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1bnN0YWJsZV9wcm9taXNlKSB7XG4gICAgICAgICAgcmV0dXJuIGFTdGF0ZS5wLnRoZW4oKCkgPT4gd3JpdGVHZXR0ZXIoYSwgdW5zdGFibGVfcHJvbWlzZSkpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGFTdGF0ZS5wO1xuICAgICAgfVxuICAgICAgaWYgKFwidlwiIGluIGFTdGF0ZSkge1xuICAgICAgICByZXR1cm4gYVN0YXRlLnY7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIltCdWddIG5vIHZhbHVlIGZvdW5kIHdoaWxlIHJlYWRpbmcgYXRvbSBpbiB3cml0ZSBvcGVyYXRpb24uIFRoaXMgaXMgcHJvYmFibHkgYSBidWcuXCIsIGEpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gdmFsdWUgZm91bmRcIik7XG4gICAgfTtcbiAgICBjb25zdCBzZXR0ZXIgPSAoYSwgdikgPT4ge1xuICAgICAgbGV0IHByb21pc2VPclZvaWQyO1xuICAgICAgaWYgKGEgPT09IGF0b20pIHtcbiAgICAgICAgaWYgKCFoYXNJbml0aWFsVmFsdWUoYSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBhdG9tIGluaXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgcHJvbWlzZU9yVm9pZDIgPSB2LnRoZW4oKHJlc29sdmVkVmFsdWUpID0+IHtcbiAgICAgICAgICAgIHNldEF0b21WYWx1ZShhLCByZXNvbHZlZFZhbHVlKTtcbiAgICAgICAgICAgIGludmFsaWRhdGVEZXBlbmRlbnRzKGEpO1xuICAgICAgICAgICAgZmx1c2hQZW5kaW5nKCk7XG4gICAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIHNldEF0b21SZWFkRXJyb3IoYXRvbSwgZSk7XG4gICAgICAgICAgICBmbHVzaFBlbmRpbmcoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZXRBdG9tUmVhZFByb21pc2UoYXRvbSwgcHJvbWlzZU9yVm9pZDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldEF0b21WYWx1ZShhLCB2KTtcbiAgICAgICAgfVxuICAgICAgICBpbnZhbGlkYXRlRGVwZW5kZW50cyhhKTtcbiAgICAgICAgZmx1c2hQZW5kaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlT3JWb2lkMiA9IHdyaXRlQXRvbVN0YXRlKGEsIHYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb21pc2VPclZvaWQyO1xuICAgIH07XG4gICAgY29uc3QgcHJvbWlzZU9yVm9pZCA9IGF0b20ud3JpdGUod3JpdGVHZXR0ZXIsIHNldHRlciwgdXBkYXRlKTtcbiAgICBmbHVzaFBlbmRpbmcoKTtcbiAgICByZXR1cm4gcHJvbWlzZU9yVm9pZDtcbiAgfTtcbiAgY29uc3Qgd3JpdGVBdG9tID0gKHdyaXRpbmdBdG9tLCB1cGRhdGUpID0+IHtcbiAgICBjb25zdCBwcm9taXNlT3JWb2lkID0gd3JpdGVBdG9tU3RhdGUod3JpdGluZ0F0b20sIHVwZGF0ZSk7XG4gICAgcmV0dXJuIHByb21pc2VPclZvaWQ7XG4gIH07XG4gIGNvbnN0IGlzQWN0dWFsbHlXcml0YWJsZUF0b20gPSAoYXRvbSkgPT4gISFhdG9tLndyaXRlO1xuICBjb25zdCBtb3VudEF0b20gPSAoYXRvbSwgaW5pdGlhbERlcGVuZGVudCkgPT4ge1xuICAgIGNvbnN0IGF0b21TdGF0ZSA9IHJlYWRBdG9tU3RhdGUoYXRvbSk7XG4gICAgYXRvbVN0YXRlLmQuZm9yRWFjaCgoXywgYSkgPT4ge1xuICAgICAgaWYgKGEgIT09IGF0b20pIHtcbiAgICAgICAgY29uc3QgYU1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhKTtcbiAgICAgICAgaWYgKGFNb3VudGVkKSB7XG4gICAgICAgICAgYU1vdW50ZWQuZC5hZGQoYXRvbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW91bnRBdG9tKGEsIGF0b20pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgbW91bnRlZCA9IHtcbiAgICAgIGQ6IG5ldyBTZXQoaW5pdGlhbERlcGVuZGVudCAmJiBbaW5pdGlhbERlcGVuZGVudF0pLFxuICAgICAgbDogbmV3IFNldCgpLFxuICAgICAgdTogdm9pZCAwXG4gICAgfTtcbiAgICBtb3VudGVkTWFwLnNldChhdG9tLCBtb3VudGVkKTtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBtb3VudGVkQXRvbXMuYWRkKGF0b20pO1xuICAgIH1cbiAgICBpZiAoaXNBY3R1YWxseVdyaXRhYmxlQXRvbShhdG9tKSAmJiBhdG9tLm9uTW91bnQpIHtcbiAgICAgIGNvbnN0IHNldEF0b20gPSAodXBkYXRlKSA9PiB3cml0ZUF0b20oYXRvbSwgdXBkYXRlKTtcbiAgICAgIG1vdW50ZWQudSA9IGF0b20ub25Nb3VudChzZXRBdG9tKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vdW50ZWQ7XG4gIH07XG4gIGNvbnN0IHVubW91bnRBdG9tID0gKGF0b20pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgb25Vbm1vdW50ID0gKF9hID0gbW91bnRlZE1hcC5nZXQoYXRvbSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS51O1xuICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgIG9uVW5tb3VudCgpO1xuICAgIH1cbiAgICBtb3VudGVkTWFwLmRlbGV0ZShhdG9tKTtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBtb3VudGVkQXRvbXMuZGVsZXRlKGF0b20pO1xuICAgIH1cbiAgICBjb25zdCBhdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgaWYgKGF0b21TdGF0ZSkge1xuICAgICAgYXRvbVN0YXRlLmQuZm9yRWFjaCgoXywgYSkgPT4ge1xuICAgICAgICBpZiAoYSAhPT0gYXRvbSkge1xuICAgICAgICAgIGNvbnN0IG1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhKTtcbiAgICAgICAgICBpZiAobW91bnRlZCkge1xuICAgICAgICAgICAgbW91bnRlZC5kLmRlbGV0ZShhdG9tKTtcbiAgICAgICAgICAgIGlmIChjYW5Vbm1vdW50QXRvbShhLCBtb3VudGVkKSkge1xuICAgICAgICAgICAgICB1bm1vdW50QXRvbShhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbQnVnXSBjb3VsZCBub3QgZmluZCBhdG9tIHN0YXRlIHRvIHVubW91bnRcIiwgYXRvbSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3VudERlcGVuZGVuY2llcyA9IChhdG9tLCBhdG9tU3RhdGUsIHByZXZSZWFkRGVwZW5kZW5jaWVzKSA9PiB7XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gbmV3IFNldChhdG9tU3RhdGUuZC5rZXlzKCkpO1xuICAgIHByZXZSZWFkRGVwZW5kZW5jaWVzLmZvckVhY2goKF8sIGEpID0+IHtcbiAgICAgIGlmIChkZXBlbmRlbmNpZXMuaGFzKGEpKSB7XG4gICAgICAgIGRlcGVuZGVuY2llcy5kZWxldGUoYSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhKTtcbiAgICAgIGlmIChtb3VudGVkKSB7XG4gICAgICAgIG1vdW50ZWQuZC5kZWxldGUoYXRvbSk7XG4gICAgICAgIGlmIChjYW5Vbm1vdW50QXRvbShhLCBtb3VudGVkKSkge1xuICAgICAgICAgIHVubW91bnRBdG9tKGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgZGVwZW5kZW5jaWVzLmZvckVhY2goKGEpID0+IHtcbiAgICAgIGNvbnN0IG1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhKTtcbiAgICAgIGlmIChtb3VudGVkKSB7XG4gICAgICAgIGNvbnN0IGRlcGVuZGVudHMgPSBtb3VudGVkLmQ7XG4gICAgICAgIGRlcGVuZGVudHMuYWRkKGF0b20pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW91bnRBdG9tKGEsIGF0b20pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBjb25zdCBmbHVzaFBlbmRpbmcgPSAoKSA9PiB7XG4gICAgY29uc3QgcGVuZGluZyA9IEFycmF5LmZyb20ocGVuZGluZ01hcCk7XG4gICAgcGVuZGluZ01hcC5jbGVhcigpO1xuICAgIHBlbmRpbmcuZm9yRWFjaCgoW2F0b20sIHByZXZBdG9tU3RhdGVdKSA9PiB7XG4gICAgICBjb25zdCBhdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgICBpZiAoYXRvbVN0YXRlICYmIGF0b21TdGF0ZS5kICE9PSAocHJldkF0b21TdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcHJldkF0b21TdGF0ZS5kKSkge1xuICAgICAgICBtb3VudERlcGVuZGVuY2llcyhhdG9tLCBhdG9tU3RhdGUsIChwcmV2QXRvbVN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBwcmV2QXRvbVN0YXRlLmQpIHx8IG5ldyBNYXAoKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBtb3VudGVkID0gbW91bnRlZE1hcC5nZXQoYXRvbSk7XG4gICAgICBtb3VudGVkID09IG51bGwgPyB2b2lkIDAgOiBtb3VudGVkLmwuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKCkpO1xuICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBzdGF0ZUxpc3RlbmVycy5mb3JFYWNoKChsKSA9PiBsKGF0b20sICFwcmV2QXRvbVN0YXRlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IGNvbW1pdEF0b20gPSAoX2F0b20pID0+IHtcbiAgICBmbHVzaFBlbmRpbmcoKTtcbiAgfTtcbiAgY29uc3Qgc3Vic2NyaWJlQXRvbSA9IChhdG9tLCBjYWxsYmFjaykgPT4ge1xuICAgIGNvbnN0IG1vdW50ZWQgPSBhZGRBdG9tKGF0b20pO1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IG1vdW50ZWQubDtcbiAgICBsaXN0ZW5lcnMuYWRkKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbGlzdGVuZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICBkZWxBdG9tKGF0b20pO1xuICAgIH07XG4gIH07XG4gIGNvbnN0IHJlc3RvcmVBdG9tcyA9ICh2YWx1ZXMpID0+IHtcbiAgICBmb3IgKGNvbnN0IFthdG9tLCB2YWx1ZV0gb2YgdmFsdWVzKSB7XG4gICAgICBpZiAoaGFzSW5pdGlhbFZhbHVlKGF0b20pKSB7XG4gICAgICAgIHNldEF0b21WYWx1ZShhdG9tLCB2YWx1ZSk7XG4gICAgICAgIGludmFsaWRhdGVEZXBlbmRlbnRzKGF0b20pO1xuICAgICAgfVxuICAgIH1cbiAgICBmbHVzaFBlbmRpbmcoKTtcbiAgfTtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiB7XG4gICAgICBbUkVBRF9BVE9NXTogcmVhZEF0b20sXG4gICAgICBbV1JJVEVfQVRPTV06IHdyaXRlQXRvbSxcbiAgICAgIFtDT01NSVRfQVRPTV06IGNvbW1pdEF0b20sXG4gICAgICBbU1VCU0NSSUJFX0FUT01dOiBzdWJzY3JpYmVBdG9tLFxuICAgICAgW1JFU1RPUkVfQVRPTVNdOiByZXN0b3JlQXRvbXMsXG4gICAgICBbREVWX1NVQlNDUklCRV9TVEFURV06IChsKSA9PiB7XG4gICAgICAgIHN0YXRlTGlzdGVuZXJzLmFkZChsKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBzdGF0ZUxpc3RlbmVycy5kZWxldGUobCk7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgW0RFVl9HRVRfTU9VTlRFRF9BVE9NU106ICgpID0+IG1vdW50ZWRBdG9tcy52YWx1ZXMoKSxcbiAgICAgIFtERVZfR0VUX0FUT01fU1RBVEVdOiAoYSkgPT4gYXRvbVN0YXRlTWFwLmdldChhKSxcbiAgICAgIFtERVZfR0VUX01PVU5URURdOiAoYSkgPT4gbW91bnRlZE1hcC5nZXQoYSlcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgW1JFQURfQVRPTV06IHJlYWRBdG9tLFxuICAgIFtXUklURV9BVE9NXTogd3JpdGVBdG9tLFxuICAgIFtDT01NSVRfQVRPTV06IGNvbW1pdEF0b20sXG4gICAgW1NVQlNDUklCRV9BVE9NXTogc3Vic2NyaWJlQXRvbSxcbiAgICBbUkVTVE9SRV9BVE9NU106IHJlc3RvcmVBdG9tc1xuICB9O1xufTtcblxuY29uc3QgY3JlYXRlU2NvcGVDb250YWluZXIgPSAoaW5pdGlhbFZhbHVlcykgPT4ge1xuICBjb25zdCBzdG9yZSA9IGNyZWF0ZVN0b3JlKGluaXRpYWxWYWx1ZXMpO1xuICByZXR1cm4geyBzOiBzdG9yZSB9O1xufTtcbmNvbnN0IFNjb3BlQ29udGV4dE1hcCA9IG5ldyBNYXAoKTtcbmNvbnN0IGdldFNjb3BlQ29udGV4dCA9IChzY29wZSkgPT4ge1xuICBpZiAoIVNjb3BlQ29udGV4dE1hcC5oYXMoc2NvcGUpKSB7XG4gICAgU2NvcGVDb250ZXh0TWFwLnNldChzY29wZSwgY3JlYXRlQ29udGV4dChjcmVhdGVTY29wZUNvbnRhaW5lcigpKSk7XG4gIH1cbiAgcmV0dXJuIFNjb3BlQ29udGV4dE1hcC5nZXQoc2NvcGUpO1xufTtcblxuY29uc3QgUHJvdmlkZXIgPSAoe1xuICBpbml0aWFsVmFsdWVzLFxuICBzY29wZSxcbiAgY2hpbGRyZW5cbn0pID0+IHtcbiAgY29uc3Qgc2NvcGVDb250YWluZXJSZWYgPSB1c2VSZWYoKTtcbiAgaWYgKCFzY29wZUNvbnRhaW5lclJlZi5jdXJyZW50KSB7XG4gICAgc2NvcGVDb250YWluZXJSZWYuY3VycmVudCA9IGNyZWF0ZVNjb3BlQ29udGFpbmVyKGluaXRpYWxWYWx1ZXMpO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwidGVzdFwiKSB7XG4gICAgdXNlRGVidWdTdGF0ZShzY29wZUNvbnRhaW5lclJlZi5jdXJyZW50KTtcbiAgfVxuICBjb25zdCBTY29wZUNvbnRhaW5lckNvbnRleHQgPSBnZXRTY29wZUNvbnRleHQoc2NvcGUpO1xuICByZXR1cm4gY3JlYXRlRWxlbWVudChTY29wZUNvbnRhaW5lckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc2NvcGVDb250YWluZXJSZWYuY3VycmVudFxuICB9LCBjaGlsZHJlbik7XG59O1xuY29uc3QgYXRvbVRvUHJpbnRhYmxlID0gKGF0b20pID0+IGF0b20uZGVidWdMYWJlbCB8fCBhdG9tLnRvU3RyaW5nKCk7XG5jb25zdCBzdGF0ZVRvUHJpbnRhYmxlID0gKFtzdG9yZSwgYXRvbXNdKSA9PiBPYmplY3QuZnJvbUVudHJpZXMoYXRvbXMuZmxhdE1hcCgoYXRvbSkgPT4ge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBtb3VudGVkID0gKF9hID0gc3RvcmVbREVWX0dFVF9NT1VOVEVEXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoc3RvcmUsIGF0b20pO1xuICBpZiAoIW1vdW50ZWQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgZGVwZW5kZW50cyA9IG1vdW50ZWQuZDtcbiAgY29uc3QgYXRvbVN0YXRlID0gKChfYiA9IHN0b3JlW0RFVl9HRVRfQVRPTV9TVEFURV0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKHN0b3JlLCBhdG9tKSkgfHwge307XG4gIHJldHVybiBbXG4gICAgW1xuICAgICAgYXRvbVRvUHJpbnRhYmxlKGF0b20pLFxuICAgICAge1xuICAgICAgICB2YWx1ZTogYXRvbVN0YXRlLmUgfHwgYXRvbVN0YXRlLnAgfHwgYXRvbVN0YXRlLnYsXG4gICAgICAgIGRlcGVuZGVudHM6IEFycmF5LmZyb20oZGVwZW5kZW50cykubWFwKGF0b21Ub1ByaW50YWJsZSlcbiAgICAgIH1cbiAgICBdXG4gIF07XG59KSk7XG5jb25zdCB1c2VEZWJ1Z1N0YXRlID0gKHNjb3BlQ29udGFpbmVyKSA9PiB7XG4gIGNvbnN0IHN0b3JlID0gc2NvcGVDb250YWluZXIucztcbiAgY29uc3QgW2F0b21zLCBzZXRBdG9tc10gPSB1c2VTdGF0ZShbXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIHNldEF0b21zKEFycmF5LmZyb20oKChfYTIgPSBzdG9yZVtERVZfR0VUX01PVU5URURfQVRPTVNdKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNhbGwoc3RvcmUpKSB8fCBbXSkpO1xuICAgIH07XG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSAoX2EgPSBzdG9yZVtERVZfU1VCU0NSSUJFX1NUQVRFXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoc3RvcmUsIGNhbGxiYWNrKTtcbiAgICBjYWxsYmFjaygpO1xuICAgIHJldHVybiB1bnN1YnNjcmliZTtcbiAgfSwgW3N0b3JlXSk7XG4gIHVzZURlYnVnVmFsdWUoW3N0b3JlLCBhdG9tc10sIHN0YXRlVG9QcmludGFibGUpO1xufTtcblxubGV0IGtleUNvdW50ID0gMDtcbmZ1bmN0aW9uIGF0b20ocmVhZCwgd3JpdGUpIHtcbiAgY29uc3Qga2V5ID0gYGF0b20keysra2V5Q291bnR9YDtcbiAgY29uc3QgY29uZmlnID0ge1xuICAgIHRvU3RyaW5nOiAoKSA9PiBrZXlcbiAgfTtcbiAgaWYgKHR5cGVvZiByZWFkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25maWcucmVhZCA9IHJlYWQ7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnLmluaXQgPSByZWFkO1xuICAgIGNvbmZpZy5yZWFkID0gKGdldCkgPT4gZ2V0KGNvbmZpZyk7XG4gICAgY29uZmlnLndyaXRlID0gKGdldCwgc2V0LCB1cGRhdGUpID0+IHNldChjb25maWcsIHR5cGVvZiB1cGRhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHVwZGF0ZShnZXQoY29uZmlnKSkgOiB1cGRhdGUpO1xuICB9XG4gIGlmICh3cml0ZSkge1xuICAgIGNvbmZpZy53cml0ZSA9IHdyaXRlO1xuICB9XG4gIHJldHVybiBjb25maWc7XG59XG5cbmNvbnN0IGlzV3JpdGFibGUgPSAoYXRvbSkgPT4gISFhdG9tLndyaXRlO1xuZnVuY3Rpb24gdXNlQXRvbShhdG9tLCBzY29wZSkge1xuICBpZiAoXCJzY29wZVwiIGluIGF0b20pIHtcbiAgICBjb25zb2xlLndhcm4oXCJhdG9tLnNjb3BlIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSBkbyB1c2VBdG9tKGF0b20sIHNjb3BlKSBpbnN0ZWFkLlwiKTtcbiAgICBzY29wZSA9IGF0b20uc2NvcGU7XG4gIH1cbiAgY29uc3QgU2NvcGVDb250ZXh0ID0gZ2V0U2NvcGVDb250ZXh0KHNjb3BlKTtcbiAgY29uc3Qgc3RvcmUgPSB1c2VDb250ZXh0KFNjb3BlQ29udGV4dCkucztcbiAgY29uc3QgZ2V0QXRvbVZhbHVlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGF0b21TdGF0ZSA9IHN0b3JlW1JFQURfQVRPTV0oYXRvbSk7XG4gICAgaWYgKFwiZVwiIGluIGF0b21TdGF0ZSkge1xuICAgICAgdGhyb3cgYXRvbVN0YXRlLmU7XG4gICAgfVxuICAgIGlmIChhdG9tU3RhdGUucCkge1xuICAgICAgdGhyb3cgYXRvbVN0YXRlLnA7XG4gICAgfVxuICAgIGlmIChcInZcIiBpbiBhdG9tU3RhdGUpIHtcbiAgICAgIHJldHVybiBhdG9tU3RhdGUudjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibm8gYXRvbSB2YWx1ZVwiKTtcbiAgfSwgW3N0b3JlLCBhdG9tXSk7XG4gIGNvbnN0IFt2YWx1ZSwgZm9yY2VVcGRhdGVdID0gdXNlUmVkdWNlcihnZXRBdG9tVmFsdWUsIHZvaWQgMCwgZ2V0QXRvbVZhbHVlKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN0b3JlW1NVQlNDUklCRV9BVE9NXShhdG9tLCBmb3JjZVVwZGF0ZSk7XG4gICAgZm9yY2VVcGRhdGUoKTtcbiAgICByZXR1cm4gdW5zdWJzY3JpYmU7XG4gIH0sIFtzdG9yZSwgYXRvbV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHN0b3JlW0NPTU1JVF9BVE9NXShhdG9tKTtcbiAgfSk7XG4gIGNvbnN0IHNldEF0b20gPSB1c2VDYWxsYmFjaygodXBkYXRlKSA9PiB7XG4gICAgaWYgKGlzV3JpdGFibGUoYXRvbSkpIHtcbiAgICAgIHJldHVybiBzdG9yZVtXUklURV9BVE9NXShhdG9tLCB1cGRhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3Qgd3JpdGFibGUgYXRvbVwiKTtcbiAgICB9XG4gIH0sIFtzdG9yZSwgYXRvbV0pO1xuICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcbiAgcmV0dXJuIFt2YWx1ZSwgc2V0QXRvbV07XG59XG5cbmV4cG9ydCB7IFByb3ZpZGVyLCBnZXRTY29wZUNvbnRleHQgYXMgU0VDUkVUX0lOVEVSTkFMX2dldFNjb3BlQ29udGV4dCwgYXRvbSwgdXNlQXRvbSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/jotai/esm/index.js\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2Ftest&absolutePagePath=%2FUsers%2Fchaa%2Fstudy%2Ftuesday%2Fjotai-sample%2Fsrc%2Fpages%2Ftest.tsx!":
/*!*******************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2Ftest&absolutePagePath=%2FUsers%2Fchaa%2Fstudy%2Ftuesday%2Fjotai-sample%2Fsrc%2Fpages%2Ftest.tsx! ***!
  \*******************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/test\",\n      function () {\n        return __webpack_require__(/*! ./src/pages/test.tsx */ \"./src/pages/test.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/test\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/cGFnZT0lMkZ0ZXN0JmFic29sdXRlUGFnZVBhdGg9JTJGVXNlcnMlMkZjaGFhJTJGc3R1ZHklMkZ0dWVzZGF5JTJGam90YWktc2FtcGxlJTJGc3JjJTJGcGFnZXMlMkZ0ZXN0LnRzeCEuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxrREFBMkQ7QUFDbEY7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzJjNTgiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi90ZXN0XCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwiL1VzZXJzL2NoYWEvc3R1ZHkvdHVlc2RheS9qb3RhaS1zYW1wbGUvc3JjL3BhZ2VzL3Rlc3QudHN4XCIpO1xuICAgICAgfVxuICAgIF0pO1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvdy5fX05FWFRfUC5wdXNoKFtcIi90ZXN0XCJdKVxuICAgICAgfSk7XG4gICAgfVxuICAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2Ftest&absolutePagePath=%2FUsers%2Fchaa%2Fstudy%2Ftuesday%2Fjotai-sample%2Fsrc%2Fpages%2Ftest.tsx!\n");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2Ftest&absolutePagePath=%2FUsers%2Fchaa%2Fstudy%2Ftuesday%2Fjotai-sample%2Fsrc%2Fpages%2Ftest.tsx!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);